<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>SAE ASP</title>

    <style>
      html,
      body {
        overflow: hidden;
        width: 100%;
        height: 100%;
        margin: 0;
        padding: 0;
      }

      #renderCanvas {
        width: 100%;
        height: 100%;
        touch-action: none;
      }
    </style>

    <script src="https://preview.babylonjs.com/babylon.js"></script>
    <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
    <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
  </head>

  <body>
    <canvas id="renderCanvas" touch-action="none"></canvas>

    <script>
      var canvas = document.getElementById("renderCanvas"); // Get the canvas element
      var engine = new BABYLON.Engine(canvas, true); // Generate the BABYLON 3D engine

      /******* Add the create scene function ******/
      var createScene = function() {
        // Create the scene space
        var scene = new BABYLON.Scene(engine);

        // // Create a FreeCamera, and set its position to (x:0, y:5, z:-10).
        // var camera = new BABYLON.UniversalCamera("UniversalCamera", new BABYLON.Vector3(0, 0, -10), scene);

        // Activate ArcCam + Camera Controlls
        var camera = new BABYLON.ArcRotateCamera(
          "cam",
          -Math.PI / 2,
          Math.PI / 2,
          10,
          BABYLON.Vector3.Zero(),
          scene
        );

        const assetPath = "/assets/chars/";

        // Attach the camera to the canvas.
        camera.attachControl(canvas, true);

        camera.minZ = 0.001;
        camera.wheelPrecision = 150;
        // Target the camera to scene origin.
        camera.setTarget(BABYLON.Vector3.Zero());

        // Add lights to the scene
        var light1 = new BABYLON.HemisphericLight(
          "light1",
          new BABYLON.Vector3(1, 1, 0),
          scene
        );
        //var light2 = new BABYLON.PointLight("light2", new BABYLON.Vector3(0, 1, -1), scene);

        // Add and manipulate meshes in the scene
        var bgPlane = BABYLON.MeshBuilder.CreatePlane(
          "plane",
          { width: 10, height: 6 },
          scene
        );
        //Create Materials
        var mat = new BABYLON.StandardMaterial("mat", scene);

        //load Asset manager
        var assetsManager = new BABYLON.AssetsManager(scene);

        //load GUI
        var gui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("GUI");

        //load Animatin GUI
        var animationGui = new BABYLON.GUI.StackPanel();
        animationGui.width = "220px";
        animationGui.fontSize = "14px";
        animationGui.horizontalAlignment =
          BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_RIGHT;
        animationGui.verticalAlignment =
          BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER;
        gui.addControl(animationGui);

        //layout for Playbutton
        var playBtn = BABYLON.GUI.Button.CreateImageOnlyButton(
          "playBtn",
          "assets/images/gui/play-button.png"
        );
        playBtn.width = "200px";
        playBtn.height = "200px";
        playBtn.color = "transparent";

        //Variables for Assets
        var introVideo = null;

        //play Intro Video (autoplay is disabled by default, so users have to interact with the website once to enable it)
        playBtn.onPointerUpObservable.add(function() {
          gui.removeControl(playBtn);
          //Play Intro Video
          playVideo(introVideo);
        });

        //axios testing
        function preLoadVideo(videoPath) {
          const getVideo = () => {
            try {
              return axios.get(videoPath);
            } catch (error) {
              console.error(error);
            }
          };

          const asignVideo = async () => {
            const video = getVideo()
              .then(response => {
                if (response.data) {
                  console.log(response.data);
                }
              })
              .catch(error => {
                console.log(error);
              });
          };
        }

        function loadVideo(video, poster) {
          var videoTexture = new BABYLON.VideoTexture(
            "video",
            video,
            scene,
            false,
            false,
            BABYLON.VideoTexture.TRILINEAR_SAMPLINGMODE,
            {
              autoUpdateTexture: true,
              poster: poster
            }
          );
          //Apply Texture
          mat.diffuseTexture = videoTexture;
          //Apply Video to BG
          bgPlane.material = mat;
          //start video
          //videoTexture.video.play();
          return videoTexture;
        }

        function playVideo(videoAsset) {
          videoAsset.video.play();
          console.log("video started");

          var htmlVideo = mat.diffuseTexture.video;
          htmlVideo.onended = function() {
            finishedVideo();
          };
        }

        function finishedVideo(video) {
          console.log("video Finished & show Assets");
          //show Assets
          mainChar.loadedMeshes[0].setEnabled(true);
          pot.loadedMeshes[0].setEnabled(true);
          console.log(mainChar);
        }

        function loadAsset(assetName, assetDir, gltfFile) {
          //load Asset
          var tmpTask = assetsManager.addMeshTask(
            assetName,
            "",
            assetPath + assetDir + "/",
            gltfFile
          );
          //on Success
          tmpTask.onSuccess = function(task) {
            task.loadedMeshes[0].setEnabled(false);
          };

          return tmpTask;
        }

        function positionAsset(task, xPosition, yPosition, zPosition) {
          mesh = task.loadedMeshes[0];
          mesh.position.x = xPosition;
          mesh.position.y = yPosition;
          mesh.position.z = zPosition;
        }

        function scaleAsset(task, xScale, yScale, zScale) {
          mesh = task.loadedMeshes[0];
          //example: mesh.scaling = new BABYLON.Vector3(60, 60, 60);
          mesh.scaling = new BABYLON.Vector3(xScale, yScale, zScale);
        }

        function rotateAsset(task, axis, rotation) {
          mesh = task.loadedMeshes[0];
          //example: mesh.rotate(BABYLON.Axis.Y, Math.PI);
          mesh.rotate(axis, rotation);
        }

        function loadAssetAnimation(loadedAsset) {
          tmpArray = loadedAsset.loadedAnimationGroups;
          tmpArray.forEach(function(element) {
            console.log("Foreach element:", element["name"]);
            createButton(element["name"]);
          });
        }

        //create btn
        function createButton(btn) {
          var btn = BABYLON.GUI.Button.CreateSimpleButton(btn, btn);
          btn.paddingTop = "10px";
          btn.width = "100px";
          btn.height = "50px";
          btn.color = "white";
          btn.background = "green";
          animationGui.addControl(btn);
          btn.onPointerUpObservable.add(function() {
            playAnimation(btn);
          });
        }

        function playAnimation(animation) {
          console.log("pressed " + animation["name"]);
        }

        //load Assets
        const mainChar = loadAsset(
          "mainChar",
          "Stromboli",
          "Stromboli_AnimLayer.gltf"
        );
        const pot = loadAsset("pot", "pot", "fbxFull.gltf");

        //load Videos
        var introVideo = loadVideo(
          "assets/videos/Cam_Portal_Main.mp4",
          "assets/poster/Cam_Portal_Main_Poster.png"
        );
        //load
        assetsManager.load();

        //after Assets are loaded load Video
        assetsManager.onFinish = function() {
          console.log("assets Manager finished");
          gui.addControl(playBtn, 0, 0);

          //position and rotate char
          positionAsset(mainChar, 1, -1, -2.5);
          rotateAsset(mainChar, BABYLON.Axis.Y, Math.PI);
          //position and rotate pot
          positionAsset(pot, 1.3, -1, -3.4);
          scaleAsset(pot, 40, 40, 40);
          rotateAsset(pot, BABYLON.Axis.Y, Math.PI);

          loadAssetAnimation(mainChar);
        };

        return scene;
      };

      /******* End of the create scene function ******/

      var scene = createScene(); //Call the createScene function

      // Register a render loop to repeatedly render the scene
      engine.runRenderLoop(function() {
        scene.render();
      });

      // Watch for browser/canvas resize events
      window.addEventListener("resize", function() {
        engine.resize();
      });
    </script>
  </body>
</html>
